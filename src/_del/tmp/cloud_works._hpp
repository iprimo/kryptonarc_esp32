//  https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/
#include "Arduino.h"
#include "WiFi.h"
#include "WiFiClientSecure.h"
#include "HTTPClient.h"
#include "system_structs.hpp"
#include "ESP32Ping.h"
#include "ArduinoJson.h"
#include<string.h>

extern SOFTWARE_GLOBAL_PARAMETERS_FIXED software_parameters_fixed;
extern E2PROM_STORED_DATA_FIXED e2prom_variables;

// https://medium.com/@sanghviyash6/migrating-any-http-request-to-https-on-esp32-5545a6de7845
// https://medium.com/@sanghviyash6/migrating-any-http-request-to-https-on-esp32-5545a6de7845

// https://www.youtube.com/watch?v=dsmMzS3Qvg0&ab_channel=techiesms
// https://www.youtube.com/watch?v=dsmMzS3Qvg0&ab_channel=techiesms
// https://github.com/techiesms/ESP8266-Series/blob/master/HTTPSRequest/HTTPSRequest.ino
// https://github.com/techiesms/ESP8266-Series/blob/master/HTTPSRequest/HTTPSRequest.ino


// const char* host_domain_subdomain = "api.github.com"; // Server from which data is to be fetched
// const char* host_domain_subdomain = "https://hw_direct.dev.kryptonarc.com/raw_hw_check"; // Server from which data is to be fetched
const char* host_domain_subdomain = "hw_direct.dev.kryptonarc.com"; // Server from which data is to be fetched
const int httpsPort = 443; // Default port for HTTPS 


// # https://stackoverflow.com/questions/68568043/esp32-https-post-json-to-aws
// # https://stackoverflow.com/questions/68568043/esp32-https-post-json-to-aws
void postToAmazonSecure(String jsonToSend){
    WiFiClientSecure client;
    
    const char* emonDataAPI = software_parameters_fixed.server_hardware_direct_ca_domain;
    const char* emonDataAPIPath = software_parameters_fixed.server_hardware_direct_ca_path;
    const char* certificate_root_ca = software_parameters_fixed.server_hardware_direct_ca_certificate ;
    Serial.print("connecting to : '");
    Serial.print(emonDataAPI);
    Serial.println("'");
    Serial.println( emonDataAPI );
    client.setCACert(certificate_root_ca);
    client.connect( emonDataAPI , 443);
    
    Serial.print("requesting URL: '");
    Serial.print(emonDataAPI);
    Serial.println("'");
    String requestString = String("POST ") + emonDataAPIPath + " HTTP/1.1\r\n" +
        "Host: " + emonDataAPI + "\r\n" +
        "User-Agent: KryptonArcHWAgent" + "ESP32" + "agentVersion" + "1" + "\r\n" +
        "Connection: close\r\n" +
        "Content-Type: application/json\r\n" +
        //"Authorization: Bearer " + authorization_code + "\r\n" +
        "Content-Length: " + jsonToSend.length() + "\r\n" +
        "\r\n" +
        jsonToSend + "\r\n";
        Serial.println(requestString);
    client.print(requestString);
    
    Serial.println("request sent");
    unsigned long timeout = millis();
    while (client.available() == 0) {
        if (millis() - timeout > 5000) {
            Serial.println(">>> Client Timeout !");
            client.stop();
            return;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////
// hardware direct status check
//  https://github.com/witnessmenow/arduino-sample-api-request/blob/master/ESP32/HTTP_GET_JSON/HTTP_GET_JSON.ino
HTTPWorksReply post2_hw_direct_statuscheck(
                                            String sEChipModel, 
                                            String sEChipRevision,
                                            String sEChipCores, 
                                            String sEChipId, 
                                            String sEMacSOFTAP, 
                                            String sEMacBT, 
                                            String sEMacETH, 
                                            String sEMacWiFi, 
                                            String sEControllerBoardHWVersion, 
                                            String sE00100
    ){
    const char* funcID = "4563456";
    const char* funcName = "post2_hw_direct_statuscheck";

    HTTPWorksReply returning_data;

    int  conn;
    DynamicJsonDocument doc( 256 );
    WiFiClientSecure client;
    
    doc["sEChipModel"] = sEChipModel;
    doc["sEChipRevision"] = sEChipRevision;
    doc["sEChipCores"] = sEChipCores;
    doc["sEChipId"] = sEChipId;
    doc["sEMacSOFTAP"] = sEMacSOFTAP;
    doc["sEMacBT"] = sEMacBT;
    doc["sEMacETH"] = sEMacETH;
    doc["sEMacWiFi"] = sEMacWiFi;
    doc["sEControllerBoardHWVersion"] = sEControllerBoardHWVersion;
    doc["sE00100"] = sE00100;

    String json;
    serializeJson(doc, json);

    const char* emonDataAPI = software_parameters_fixed.server_hardware_direct_ca_domain;
    const char* emonDataAPIPath = "/raw_hw/statuscheck";
    const char* certificate_root_ca = software_parameters_fixed.server_hardware_direct_ca_certificate ;
    Serial.println("LogMessage: Connecting to : '"); Serial.print(emonDataAPI); Serial.println("'");
    client.setCACert(certificate_root_ca);
    conn = client.connect( emonDataAPI , 443);
    
    if (conn == 1) {
        String requestString = String("POST ") + emonDataAPIPath + " HTTP/1.1\r\n" +
            "Host: " + emonDataAPI + "\r\n" +
            "User-Agent: KryptonArcHWAgent" + "ESP32" + "agentVersion" + "1" + "\r\n" +
            "Connection: close\r\n" +
            "Content-Type: application/json\r\n" +
            // "Cache-Control: no-cache\r\n" +
            //"Authorization: Bearer " + authorization_code + "\r\n" +
            "Content-Length: " + json.length() + "\r\n" +
            "\r\n" +
            json + "\r\n";
        Serial.println("LogMessage: Sending request: "); Serial.println(requestString);
        
        client.print(requestString);
        // if (client.println() == 0)
        // {
        //     Serial.println(F("Failed to send request"));
        //     return;
        // }
        
        Serial.println("request sent");
        Serial.println("Waiting for reply... ");
        unsigned long timeout = millis();
        
        while (client.available() == 0) {
            Serial.print(".");
            if (millis() - timeout > 20000) {
                Serial.println(">>> Client Timeout !");
                client.stop();
                // return "request timeout";
                // return;

                returning_data.bEServerReachableLogic = false;
                returning_data.bEServerRespondedLogic = false;
                returning_data.bEDeviceRegisteredLogic = false;
                returning_data.sEMessage = ">>> Client Timeout !";
                return returning_data;
            }
        }

        // Serial.println();
        // Serial.println("Got response");
        // Serial.println("return status: ");
        // String response = client.readStringUntil('\n');
        // Serial.println(response.c_str());

        ////////////////////////////////////////////////////////////////////////////////////////
        //Print Server Response

        // Check HTTP status
        char status[32] = {0};
        client.readBytesUntil('\r', status, sizeof(status));
        if (strcmp(status, "HTTP/1.1 200 OK") != 0)
        {
            Serial.print(F("Unexpected response: "));
            Serial.println(status);
            // return;
            returning_data.bEServerReachableLogic = true;
            returning_data.bEServerRespondedLogic = false;
            returning_data.bEDeviceRegisteredLogic = false;
            returning_data.sEMessage = "Unexpected response: ";
            return returning_data;
        }

        // Skip HTTP headers
        char endOfHeaders[] = "\r\n\r\n";
        if (!client.find(endOfHeaders))
        {
            Serial.println(F("Invalid response"));
            returning_data.bEServerReachableLogic = true;
            returning_data.bEServerRespondedLogic = false;
            returning_data.bEDeviceRegisteredLogic = false;
            returning_data.sEMessage = "Invalid response";
            return returning_data;
        }

        // This is probably not needed for most, but I had issues
        // with the Tindie api where sometimes there were random
        // characters coming back before the body of the response.
        // This will cause no hard to leave it in
        // peek() will look at the character, but not take it off the queue
        while (client.available() && client.peek() != '{')
        {
            char c = 0;
            client.readBytes(&c, 1);
            Serial.print(c);
            Serial.println("BAD");
        }

        //  // While the client is still availble read each
        //  // byte and print to the serial monitor
        //  while (client.available()) {
        //    char c = 0;
        //    client.readBytes(&c, 1);
        //    Serial.print(c);
        //  }

        //Use the ArduinoJson Assistant to calculate this:
        //StaticJsonDocument<192> docReturned;
        DynamicJsonDocument docReturned(64); //For ESP32/ESP8266 you'll mainly use dynamic.

        DeserializationError error = deserializeJson(docReturned, client);

        if (error) {
            Serial.print(F("deserializeJson() failed: ")); Serial.println(error.f_str());

            returning_data.bEServerReachableLogic = true;
            returning_data.bEServerRespondedLogic = false;
            returning_data.bEDeviceRegisteredLogic = false;
            returning_data.sEMessage = "deserializeJson() failed: ";
            return returning_data;
        }

        const char*  s__E_Message = docReturned["sEMessage"];
        Serial.print("s__E_Message: "); Serial.println(s__E_Message);



        Serial.println("closing connection");
        client.stop();

        if ( strcmp(docReturned["sEMessage"] , "deviceNotRegistered" ) == 0 ){
            returning_data.bEDeviceRegisteredLogic = false;
            returning_data.sEMessage = "deviceNotRegistered";
        } else {
            returning_data.bEDeviceRegisteredLogic = true;
            returning_data.sEMessage = "Registered";
        }
        returning_data.bEServerReachableLogic = true;
        returning_data.bEServerRespondedLogic = true;
        return returning_data;
        

    } else {
        client.stop();
        Serial.println("Connection Failed");

        returning_data.bEServerReachableLogic = false;
        returning_data.bEServerRespondedLogic = false;
        returning_data.bEDeviceRegisteredLogic = false;
        returning_data.sEMessage = "Connection Failed";
        return returning_data;
    }

}


